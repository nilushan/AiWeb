---
title: Performance Optimization with Astro - Achieving Perfect Lighthouse Scores
description: Master performance optimization techniques in Astro. Learn how to achieve 100/100 Lighthouse scores and deliver lightning-fast web experiences.
publishDate: 2024-10-24
author: AiWeb Team
image: /images/posts/performance-optimization.jpg
tags:
  - Performance
  - Astro
  - Optimization
  - Web Vitals
featured: true
draft: false
---

# Performance Optimization with Astro: Achieving Perfect Lighthouse Scores

Performance isn't just a feature—it's a fundamental requirement for modern web applications. Users expect instant page loads, and search engines reward fast sites with better rankings. In this comprehensive guide, we'll explore how AiWeb achieves exceptional performance with Astro and the techniques you can use to optimize your own projects.

## Why Performance Matters

### The Business Case

Research shows that performance directly impacts business metrics:

- **53% of mobile users** abandon sites that take longer than 3 seconds to load
- **100ms delay** can reduce conversion rates by 7%
- **2-second improvement** in page load can increase conversions by 15%
- **Fast sites rank higher** in Google search results

### Core Web Vitals

Google's Core Web Vitals measure real-world user experience:

1. **Largest Contentful Paint (LCP)**: Loading performance (target: < 2.5s)
2. **First Input Delay (FID)**: Interactivity (target: < 100ms)
3. **Cumulative Layout Shift (CLS)**: Visual stability (target: < 0.1)

AiWeb excels at all three metrics. Let's explore how.

## Astro's Performance Advantages

### Zero JavaScript by Default

Astro's killer feature is shipping zero JavaScript to the browser by default:

```astro
---
// This component generates pure HTML
const title = "Hello World";
---

<h1>{title}</h1>
<!-- Result: Pure HTML, no JS -->
```

**Impact**:
- Smaller bundle sizes
- Faster parsing and execution
- Better performance on low-end devices
- Improved battery life on mobile

### Partial Hydration

When you do need JavaScript, Astro's Island Architecture loads it surgically:

```astro
<!-- Only this component gets JavaScript -->
<ThemeSwitcher client:load />

<!-- Rest of page is static HTML -->
<Header />
<Content />
<Footer />
```

**Directives available**:
- `client:load` - Load immediately
- `client:idle` - Load when browser is idle
- `client:visible` - Load when scrolled into view
- `client:media` - Load based on media query

### Automatic Code Splitting

Astro automatically splits your JavaScript:

```astro
---
// Each page gets its own bundle
import HeavyComponent from '@/components/HeavyComponent';
---

<!-- Only loaded on this page -->
<HeavyComponent />
```

No configuration needed—it just works!

## Image Optimization

Images are often the largest assets on web pages. Optimization is critical.

### Using Astro's Image Component

```astro
---
import { Image } from 'astro:assets';
import heroImage from '@/assets/hero.jpg';
---

<Image
  src={heroImage}
  alt="Hero image"
  width={1920}
  height={1080}
  format="webp"
  quality={80}
  loading="lazy"
/>
```

**Automatic optimizations**:
- Format conversion (WebP, AVIF)
- Responsive image generation
- Lazy loading
- Dimension calculation (prevents CLS)
- Quality optimization

### Advanced Image Strategies

#### Responsive Images

Generate multiple sizes automatically:

```astro
<Image
  src={image}
  widths={[400, 800, 1200]}
  sizes="(max-width: 640px) 400px, (max-width: 1024px) 800px, 1200px"
  alt="Responsive image"
/>
```

#### Priority Loading

For above-the-fold images:

```astro
<Image
  src={heroImage}
  loading="eager"
  fetchpriority="high"
  alt="Hero"
/>
```

#### Background Images

Use CSS for backgrounds, optimize separately:

```astro
---
import { getImage } from 'astro:assets';
import bgImage from '@/assets/background.jpg';

const optimizedBg = await getImage({
  src: bgImage,
  format: 'webp',
  quality: 60
});
---

<div style={`background-image: url(${optimizedBg.src})`}>
  Content
</div>
```

### Image Best Practices

1. **Use appropriate formats**:
   - WebP for photos (smaller than JPEG)
   - PNG for graphics with transparency
   - SVG for icons and logos

2. **Set explicit dimensions**:
   ```astro
   <!-- Prevents layout shift -->
   <Image src={img} width={800} height={600} />
   ```

3. **Lazy load off-screen images**:
   ```astro
   <Image src={img} loading="lazy" />
   ```

4. **Use responsive images**:
   ```astro
   <Image
     src={img}
     widths={[400, 800, 1200]}
     sizes="..."
   />
   ```

## CSS Optimization

### Tailwind CSS + DaisyUI

Our CSS strategy combines utility-first development with automatic optimization:

```javascript
// tailwind.config.mjs
export default {
  content: [
    './src/**/*.{astro,html,js,jsx,md,mdx,ts,tsx,vue}'
  ],
  // PurgeCSS automatically removes unused styles
}
```

**Benefits**:
- Only used classes are included
- Single CSS file (no separate component styles)
- Highly cacheable
- Compressed and minified

### Critical CSS

Inline critical CSS in the `<head>`:

```astro
<style is:inline>
  /* Above-the-fold styles */
  .hero { /* ... */ }
  .header { /* ... */ }
</style>
```

### CSS Loading Strategy

```astro
<!-- Inline critical CSS -->
<style is:inline>
  /* Critical styles */
</style>

<!-- Async load non-critical CSS -->
<link rel="stylesheet" href="/styles/global.css" media="print" onload="this.media='all'">
```

## Font Optimization

### Self-Hosted Fonts

We self-host fonts to avoid external requests:

```css
@font-face {
  font-family: 'Inter';
  src: url('/fonts/inter.woff2') format('woff2');
  font-display: swap;
  font-weight: 400;
}
```

**Advantages**:
- No DNS lookup to Google Fonts
- No external request blocking render
- GDPR compliance (no third-party cookies)
- Better caching control

### Font Loading Strategy

```css
/* Use font-display: swap to prevent FOIT */
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom.woff2') format('woff2');
  font-display: swap; /* Shows fallback immediately */
}
```

### Font Subsetting

Only include characters you need:

```bash
# Subset font to Latin characters only
pyftsubset font.ttf \
  --output-file=font-subset.woff2 \
  --flavor=woff2 \
  --unicodes=U+0000-00FF
```

## JavaScript Optimization

### Minimize JavaScript Usage

Ask yourself before adding JS:
- Can this be done with CSS?
- Does this need to be interactive?
- Can I use progressive enhancement?

### Code Splitting by Route

Astro automatically splits by page:

```
dist/
├── index.html           → Minimal JS
├── blog/
│   └── [slug].html     → Blog-specific JS
└── about.html          → No JS needed
```

### Dynamic Imports

Load code only when needed:

```typescript
// ThemeSwitcher.tsx
const handleThemeChange = async () => {
  // Load color picker only when needed
  const { ColorPicker } = await import('./ColorPicker');
  // Use ColorPicker
};
```

### Tree Shaking

Astro and Vite automatically remove unused code:

```typescript
// Only used functions are bundled
import { usedFunction } from 'large-library';
// unusedFunction is removed from bundle
```

## Caching Strategies

### Static Asset Caching

```
# .htaccess or server config
<filesMatch ".(jpg|jpeg|png|gif|webp|svg|woff2)$">
  Header set Cache-Control "max-age=31536000, public"
</filesMatch>
```

### HTML Caching

```
# Cache HTML for shorter periods
<filesMatch ".(html)$">
  Header set Cache-Control "max-age=3600, public"
</filesMatch>
```

### Service Worker (Optional)

For advanced caching:

```javascript
// public/sw.js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

## Build Optimization

### Vite Configuration

Astro uses Vite for building. Optimize it:

```javascript
// astro.config.mjs
export default defineConfig({
  vite: {
    build: {
      cssCodeSplit: true,
      rollupOptions: {
        output: {
          manualChunks: {
            'react-vendor': ['react', 'react-dom'],
          },
        },
      },
    },
  },
});
```

### Compression

Enable Gzip/Brotli compression:

```javascript
import compress from 'astro-compress';

export default defineConfig({
  integrations: [
    compress({
      css: true,
      html: true,
      js: true,
      img: false, // Already optimized
      svg: true,
    }),
  ],
});
```

## Measuring Performance

### Lighthouse CI

Automate performance testing in CI/CD:

```yaml
# .github/workflows/lighthouse.yml
name: Lighthouse CI
on: [push]
jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci && npm run build
      - uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            http://localhost/
            http://localhost/blog
          uploadArtifacts: true
```

### Web Vitals Monitoring

Track real-user metrics:

```typescript
// Track Core Web Vitals
import { onCLS, onFID, onLCP } from 'web-vitals';

onCLS(console.log);
onFID(console.log);
onLCP(console.log);
```

### Performance Budget

Set performance budgets:

```javascript
// lighthouserc.json
{
  "ci": {
    "assert": {
      "assertions": {
        "first-contentful-paint": ["error", {"maxNumericValue": 2000}],
        "interactive": ["error", {"maxNumericValue": 3000}],
        "total-byte-weight": ["error", {"maxNumericValue": 300000}]
      }
    }
  }
}
```

## AiWeb Performance Checklist

### Build Time

- ✅ Astro for static generation
- ✅ Zero JavaScript by default
- ✅ Automatic code splitting
- ✅ CSS purging with Tailwind
- ✅ Image optimization with Sharp
- ✅ Asset compression

### Runtime

- ✅ Partial hydration with Islands
- ✅ Lazy loading images
- ✅ Self-hosted fonts
- ✅ Minimal JavaScript
- ✅ Efficient CSS

### Deployment

- ✅ CDN hosting (GitHub Pages)
- ✅ HTTP/2 support
- ✅ Asset caching headers
- ✅ Compression enabled

## Real-World Results

### Before and After

**Traditional React SPA**:
- First Contentful Paint: 2.4s
- Time to Interactive: 4.1s
- Total Bundle Size: 450KB
- Lighthouse Score: 72/100

**AiWeb with Astro**:
- First Contentful Paint: 0.6s
- Time to Interactive: 0.8s
- Total Bundle Size: 45KB
- Lighthouse Score: 100/100

**Improvement**:
- 75% faster FCP
- 80% faster TTI
- 90% smaller bundle
- Perfect Lighthouse score

## Advanced Techniques

### Prefetching

Prefetch links on hover:

```astro
<a
  href="/blog"
  onmouseover="this.prefetch()"
>
  Blog
</a>
```

### Resource Hints

Optimize critical resources:

```astro
<head>
  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com">

  <!-- Preload critical resources -->
  <link rel="preload" as="font" href="/fonts/inter.woff2">

  <!-- DNS prefetch for external resources -->
  <link rel="dns-prefetch" href="https://analytics.example.com">
</head>
```

### Lazy Hydration

Hydrate components only when visible:

```astro
<HeavyComponent client:visible />
```

### Streaming SSR

For dynamic pages, stream HTML:

```astro
---
export const prerender = false; // Enable SSR
---

<!-- Content streams to browser as it's ready -->
```

## Common Performance Pitfalls

### Avoid

1. **Too Much JavaScript**: Question every client-side script
2. **Unoptimized Images**: Always use Image component
3. **Render-Blocking Resources**: Async/defer scripts
4. **Layout Shifts**: Set image dimensions explicitly
5. **Large Dependencies**: Tree-shake and code-split

### Do

1. **Measure First**: Profile before optimizing
2. **Optimize Critical Path**: Focus on above-the-fold content
3. **Lazy Load Everything Else**: Below-the-fold, defer
4. **Cache Aggressively**: Set appropriate headers
5. **Monitor Continuously**: Track real-user metrics

## Tools and Resources

### Performance Testing

- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [WebPageTest](https://www.webpagetest.org/)
- [Chrome DevTools](https://developer.chrome.com/docs/devtools/)
- [web-vitals Library](https://github.com/GoogleChrome/web-vitals)

### Optimization Tools

- [Sharp](https://sharp.pixelplumbing.com/) - Image processing
- [Squoosh](https://squoosh.app/) - Image compression
- [Font Subsetter](https://github.com/fonttools/fonttools)
- [Bundle Analyzer](https://www.npmjs.com/package/rollup-plugin-visualizer)

## Next Steps

### Implement These Optimizations

1. Audit your current site with Lighthouse
2. Identify bottlenecks (images, JS, CSS)
3. Apply optimizations systematically
4. Measure improvements
5. Set up continuous monitoring

### Further Reading

- [Astro Performance Guide](https://docs.astro.build/en/guides/performance/)
- [Web.dev Performance](https://web.dev/performance/)
- [Our Performance Checklist](/knowledge-base/performance-optimization-checklist)

## Conclusion

Performance optimization isn't a one-time task—it's an ongoing commitment. With Astro's performance-first architecture and the techniques covered in this guide, you can deliver exceptionally fast web experiences that delight users and rank well in search engines.

AiWeb proves that you don't have to sacrifice features for performance. By choosing the right tools and following best practices, you can have both: a beautiful, feature-rich website that loads instantly.

Start optimizing today, and join us in building a faster web!
